#### 教材的图 1-5。
   ![](https://pan.lmio.xyz/mio/pic/1acb6ea999641bfd2890bd6bc380de13.jpeg)

#### Noam Chomsky 的四类文法
   
   几类文法的差别在于对产生式施加不同的限制，分别是：
*  <font color="#ff0000">0 型文法</font> ([短语结构文法](https://www.baike.com/wikiid/1629997799439991160?from=wiki_content&prd=innerlink))(phrase structure grammars)：

   设 G =（VN，VT，P，S），如果它的每个产生式是这样一种结构：α∈(VN∪VT)*　且至少含有一个非终结符，而β∈(VN∪VT)*，则 G 是一个 0 型文法。

*  <font color="#ff0000">1 型文法</font>（上下文有关文法）(context-sensitive grammars)：

   设 G =（VN，VT，P，S）为一文法，若中的每一个产生式均满足|β|>=|α|，仅仅α→ε除外，则文法 G 是 1 型或上下文有关的。

* <font color=" #ff0000 ">2 型文法</font>（[上下文无关文法](https://www.baike.com/wikiid/4801807070024549232?from=wiki_content&prd=innerlink)）(context-free grammars)： 

   设 G =（VN，VT，P，S），若 P 中的每一个产生式满足：α是非终结符，β∈(VN∪VT)*，同时又满足 1 型文法的条件，则此文法称为 2 型的或上下文无关的。

*  <font color="#ff0000">3 型文法</font>（[正规文法](https://www.baike.com/wikiid/1913035081313240466?from=wiki_content&prd=innerlink)）(regular grammars)： 

   设 G =（VN，VT，P，S），若中的每一个产生式的形式都是 A→aB 或 A→a，其中 A 和 B 都是非终结符，a 是终结符，则 G 是 3 型文法或正规文法。

   0 型文法产生的语言称为 0 型语言。

   1 型文法产生的语言称为 1 型语言，也称作上下文有关语言。

   2 型文法产生的语言称为 2 型语言，也称作[上下文无关语言](https://www.baike.com/wikiid/1859083507378455532?from=wiki_content&prd=innerlink)。

   3 型文法产生的语言称为 3 型语言，也称作[正规语言](https://www.baike.com/wikiid/4905508579130313436?from=wiki_content&prd=innerlink)。
   
#### 教材的 3.2.1，进一步地，要能够给制最左或最右推导的语法树。
   
#### 为特定的字符串写出相应的正规式。例如，设字母表为{x, y}，，请写出包含子串 xyx 的所有串
   
#### 构造 NFA，例如，教材第 21 页的例 2.6
   ![](https://pan.lmio.xyz/mio/pic/3ba4bee73d0daf66c8538827035023aa.jpeg)
#### 文法左递归的判断与消除。
   若文法 G 中的非终结符 A，对某个文法符号序列α存在推导 A=>Aα，则称 G 是左递归的。若 G 中有形如 A→Aα的产生式，则称该产生式对 A 直接左递归  
   
   a)<font color=" #ff0000 ">把直接左递归改写为右递归</font>：  
   设有文法产生式：A→Aβ|γ。其中β非空，γ不以 A 打头。  
   可写为：  
   A→γA'  
   A'→βA'|ε  
   一般情况下，假定关于 A 的产生式是：  
	A→Aα1| Aα2 |… |Aαm|β1|β2 |…|βn  
   其中，αi (1≤i≤m) 均不为空，βj (1≤j≤n) 均不以 A 打头。  
   则消除直接左递归后改写为：  
	A→ β1A'| β2 A' |…| βnA'  
	A'→ α1A' | α2A' |…| αmA' |ε  
	
   b)<font color=" #ff0000 ">消除间接左递归</font>：  
   对于间接左递归的消除需要先将间接左递归变为直接左递归，然后再按 a) 清除左递归。  
   例：以文法 G6 为例消除左递归：  
	(1) A→aB  
	(2) A→Bb  
	(3) B→Ac  
	(4) B→d  

   解：用产生式 (1)，(2) 的右部代替产生式 (3) 中的非终结 A 得到左部为 B 的产生式：  
	(1) B→aBc  
	(2) B→Bbc  
	(3) B→d   
	
	
#### 画程序流图。参名教材第 160 页的图 5-3。
   ![](https://pan.lmio.xyz/mio/pic/e388472cfd1c14b0772ccd3679945d5e.jpg)

#### 文法的二义性的证明。

   <font color="#ff0000">二义性</font>：若文法 G 对同一句子产生不止一棵分析树，则称 G 是二义的.
   - 改写二义文法为非二义文法；  
   - 规定二义文法中符号的优先级和结合性，使仅产生一棵分析树。
1. 翻译成四式序列。参考第 133 页的例 4.7
   例 4.7 将下面的语句翻译成四元式：
```c
if(a∧b)
	while (x<y)
		if (m≠n)
			m=n;
		else
   		m=m+1;
else
	while (m>n)
		x=x+y;
```
   ![](https://pan.lmio.xyz/mio/pic/a6a2bf58297375024837053f62f56424.jpg)
```armasm
100(jnz, a, _, 102)
101(j, _, _, 113)
102(jnz, b, _, 104)
103(j, _, _, 113)
104(j<, x, y, 106)
105(j, _, _, 112) 
106(j!=, m, n, 108)
107(j, _, _, 110)
108(=, n, _, m)
109(j, _, _, 111) 
110(+, m, 1, m)
111(j, _, _, 104)
112(j, _, _, 117)
113(j>, m, n, 115)
114(j, _, _, 117)
115(+, x, y, x)
116(j, _, _, 113)
117
```

#### LL（1)，参考教材第 59 页的例 3.8。
   ![](https://pan.lmio.xyz/mio/pic/370b4917f0a17a1b18bec6cd5d33b129.jpg)
   ![](https://pan.lmio.xyz/mio/pic/bfdfc42cee6300cdd3f62115abe8a379.jpg)

#### 自底向上的语法分析文法的基础知识。


LL (1) 分析法是自上而下的分析法。LR (0), LR (1), SLR (1), LALR (1) 是自下而上的分析法。

自上而下:从开始符号出发，根据产生式规则推导给定的句子。用的是推导。

自下而上:从给定的句子规约到文法的开始符号。用的是归约。

下面就主要来讲解他们的不同点， LL (1) 单独讲，其他四种文法分析过程基本有三大步：写出自动机（即 LR (0) 或 LR (1) 项集族，后面都称作自动机） -> 构造文法分析表-> 进行文法分析过程。其中后两步都是类似或者说几乎完全一样的，第一步中的自动机有两种: LR (0) 自动机和 LR (1) 自动机。LR (0) 和 SLR 文法分析用的是 LR (0) 自动机，LR (1) 和 LALR 文法分析用的是 LR (1) 自动机。而 LR (1) 自动机构造方法和 LR (0) 自动机的构造方法相同，只是多增加了向前搜索符号


### 自下而上语法分析

☆自上而下分析采用的是推导;自下而上分析采用的是归约(规范归约—剪句柄—移进/归约分析—SLR(1)分析器).

**（1）自下而上分析的基本方法**

☆<span style="background:#d3f8b6">基本思想</span>：最左归约.

   对于每个输入序列ω：从左到右扫描ω; 从ω开始, 反复用产生式的左部替换产生式的右部 (即当前句型中的句柄)、谋求对ω的匹配, 最终得到文法的开始符号，或者发现一个错误。

☆<span style="background:#d3f8b6">基本概念</span>：

   a)>设αβδ是文法 G 的一个句型，若存在 S=*>αAδ，A=+>β，则称β是句型αβδ相对于 A 的"短语".

> 	特别的，若有 A→β，则称β是句型αβδ相对于产生式 A→β的"直接短语".

>	一个句型的最左直接短语被称为"句柄".

<font color="#ff0000">特征</font>：

   1. 短语：以非终结符为根子树中所有从左到右的叶子；

   2. 直接短语：只有父子关系的子树中所有从左到右排列的叶子（树高为 2）；

   3. 句柄：最左边父子关系树中所有从左到右排列的叶子（句柄是唯一的）

<font color="#ff0000">b)最左归约</font>：若α是文法G的句子且满足下述条件，则称序列αn，αn-1，...，α0是α的一个最左归约。

   1)αn=α

   2)α0=S（S 是 G 的开始符号）

   3) 对任何 i (0<i<=n)，αi-1 是将αi 中句柄替换为相应产生式左部非终结符得到的

☆最左归约的逆过程是一个最右推导，分别称最右推导和最左归约为规范推导和规范归约.

<font color="#ff0000">c）移进-归约分析器</font>

   1. 工作方式：格局与格局变换

   2. 分析表

   3. 驱动器（模拟算法）

   4. SLR 分析表的构造

   5. LR（文法、语言、分析器）

☆<font color=" #ff0000 ">改变格局的动作</font>：
   1. 移进 (shift)：当前剩余输入的下一终结符进栈。
   2. 归约 (reduce)：将栈顶句柄替换为对应非终结符 (最左归约) 
   3. 接受 (accept)：宣告分析成功 
   4. 报错 (error)：发现语法错误，调用错误恢复例程

![IMG_264](file:///C:/Users/86133/AppData/Local/Temp/msohtmlclip1/01/clip_image001.gif)

**(2)LR分析**

<font color="#ff0000">a)LR分析与LR文法</font>  
   LR 分析：允许左递归，但不能有二义

   定义 3.15 若为文法 G 构造的移进-归约分析表中不含多重定义的条目，则称 G 为"LR (k) 文法"，分析器被称为是"LR (k) 分析器"，它所识别的语言被称为"LR (k) 语言"。"L"表示从左到右扫描输入序列，"R"表示逆序的最右推导，"k"表示为确定下一动作向前看的终结符个数，一般情况下 k<=1。当 k=1 时，简称"LR"。

构造SLR(1)分析器

<font color=" #ff0000 ">1 活前缀与 LR (0) 项目</font>

|第 1 步|第 2~N 步|状态|
| - | - | - |
|词法--DFA|ε-closure (S), ε-closure (smove (S, a))|状态集|
|语法--DFA|closure (I), closure (goto (I, x))|项目集|

出现在移进-归约分析器栈中的右句型的前缀，被称为文法 G 的活前缀 (viable prefix).  
LR(0)项目(简称项目)是这样一个产生式，在它右边的某个位置有一个点"."。对于A→ε，它仅有一个项目A→.。  
项目A→α.β显示了分析过程中看到(移进)了产生式的多少。  
β不为空的项目称为可移进项目，β为空的项目称为可归约项目.

<font color=" #ff0000 ">2 拓广文法与识别活前缀的 DFA</font>

G'=G∪{S'→S}  
其中：S'→S 是识别 S 的初态，S'→S.是识别 S 的终态. 目的是使最终构造的 DFA 状态集中具有唯一的初态和终态.  
1. closure (I)：从项目集 I 不经任何文法符号到达的项目全体；

2. goto (I，x)：所有从 I 经文法符号 x 能直接到达的项目全体。

项目[S’→.S]和所有“.”不在产生式右部最左边的项目称为核心项目(kernel items)，

其它“.”在产生式右部最左边的项目(不包括[S’→.S])称为非核心项目(nonkernel items).

核心项目：J=goto(I，X)，S'→.S（作为项目集的代表）

非核心项目：closure(J)-J（特点：可由J某中某项目算得）

![IMG_265](file:///C:/Users/86133/AppData/Local/Temp/msohtmlclip1/01/clip_image001.gif)

<font color="#ff0000">3 识别活前缀</font>

定义3.21若存在最右推导S’=*>αAω=>αβ1β2ω，则称项目[A→β1.β2]对活前缀αβ1有效。

当一个项目集中同时存在：

1.A→β1.β2和B→β.：既可移进又可归约，移进/归约冲突

2.A→α.和B→β.：均可指导下一步分析，归约/归约冲突

解决方法：简单向前看一个终结符：

1.移进/归约冲突：若FIRST(β2)∩FOLLOW(B)=Φ，冲突可解决

2.归约/归约冲突：若FOLLOW(A)∩FOLLOW(B)=Φ，冲突可解决

若冲突可以解决，则称文法为SLR(1)文法，构造的分析表为SLR(1)分析表。

SLR(1)文法：简单向前看一个终结符即可解决冲突


## 作业题

### 第一章：
----

- 1.2 计算机执行用高级语言编写的程序有哪些途径? 它们之间主要区别是什么?
  
  计算机执行用高级语言编写的程序主要有两种途径：<font color=" #ff0000 ">解释</font>和<font color=" #ff0000 ">编译</font>。
  
  <font color="#ff0000">在解释方式下</font>，翻译程序事先并不采用将高级语言程序全部翻译成机器代码程序，然后执行这个机器代码程序的方法，而是每读入一条源程序的语句，就将其**解释**成对应其功能的机器代码语句串并执行，然后再读入下一条源程序语句并解释执行，而所翻译的机器代码语句串在该语句执行后并不保留。这种方法是按源程序中语句的动态执行顺序逐句**解释**执行的，如果一语句处于一循环体中，则每次循环执行到该语句时，都要将其翻译成机器代码后再执行。
  
  <font color="#ff0000">在编译方式下</font>，高级语言程序的执行是分两步进行的；第一步首先将高级语言程序全部翻译成机器代码程序，第二步才是执行这个机器代码程序。因此，编译对源程序的处理是先翻译，后执行。
  
  <font color="#ff0000">从执行速度上看</font>，编译型的高级语言比解释型的高级语言要快，但解释方式下的人机界面比编译型好，便于程序调试。
  
 这两种途径的主要区别在于：解释方式下不生成目标代码程序，而编译方式下生成目标代码程序。
  
  
- 1.3 请画出编译程序的总框图。如果你是一个编译程序的总设计师，设计编译程序时应当考虑哪些问题?
  
  <font color="#ff0000">编译程序总框图</font>如下：
  ![](https://pan.lmio.xyz/mio/pic/3c01d15b4da3aecf8b2c257edb45a049.jpg)

  作为一个编译程序的总设计师  
  
  - 首先要<font color="#ff0000">深刻理解被编译的源语言其语法及语义</font>；
  - 其次，<font color="#ff0000">要充分掌握目标指令的功能及特点</font>，如果目标语言是机器指令，还要搞清楚机器的硬件结构以及操作系统的功能；
  - 第三，<font color="#ff0000">对编译的方法及使用的软件工具也必须准确化</font>。总之，总设计师在设计编译程序时必须估量系统功能要求、硬件设备及软件工具等诸因素对编译程序构造的影响。
  



### 第二章：
----

1. 词法分析所依据的是什么？  
   根据<font color=" #ff0000 ">构词规则</font>编写的<font color="#ff0000">有限自动机</font>
  
2. 什么是扫描器？扫描器的功能是什么？  
   
   <font color="#ff0000">扫描器就是词法分析器</font>，它接受输入的源程序，对源程序进行词法分析并识别出一个个单词符号，其输出结果是单词符号，供语法分析器使用。通常把词法分析器作为一个子程序，每当语法分析器需要一个单词符号时就调用这个子程序。每次调用时，词法分析器就从输入串中识别出一个单词符号交给语法分析器。
   
3. 设 M=({x, y},{a, b}, f, x,{y}) 为一非确定的有限自动机，其中 f 定义如下：  
   F (x, a)={x, y}     f (x, b)={y}  
   F (y, a)=Φ       f (y, b)={x, y}  
   试构造相应的确定有限自动机 M’。  ![](https://pan.lmio.xyz/mio/pic/3ba4bee73d0daf66c8538827035023aa.jpg)


### 第三章：
----

1. 语法可以用什么文法来描述？  
   上下文无关文法
   
2. 语义需要用什么文法来描述？  
   上下文有关文法
   
3. 终结符号、非终结符号的区别是什么？  
   - <font color=" #ff0000 ">终结符号</font>：不是一个语法成分，表示他本身，是不需要被解释的符号。   
   - <font color=" #ff0000 ">非终结符号</font>：表示一个语法成分，是需要被进一步解释的符号
     
4. 最左推导、最右推导的区别是什么？  
   - <font color="#ff0000">最左推导</font>:每一步替换`最左边`的非终结符  
   - <font color="#ff0000">最右推导</font>:每一步替换`最右边`的非终结符
5. （1）令文法 G[N]为  
   `G[N]:N->D|ND`  
   `D->0|1|2|3|4|5|6|7|8|9`  
   1. `G[N]` 的语言 `L[G]` 是什么？  
      `G[N]` 的语言 `L[G]` 是<font color=" #ff0000 ">非负整数</font>  
   2. 给出句子 0127，34 和 568 的最左推导和最右推导。  
      <font color=" #ff0000 ">最左推导</font>:  
      N=>ND⇒NDD⇒NDDD⇒DDDD⇒0DDD⇒01DD⇒012D⇒0127  
      N⇒ND⇒DD⇒3D⇒34  
      N=>ND⇒NDD⇒DDD⇒5DD⇒56D⇒568  
      
      <font color=" #ff0000 ">最右推导</font>:  
      N⇒ND⇒N7⇒ND7⇒N27⇒ND27⇒N127⇒D127⇒0127  
      N⇒ND⇒N4⇒D4⇒34  
      N⇒ND⇒N8⇒ND8⇒N68⇒D68⇒568  
      
6. 已知文法 `G[S]` 为 `S->aSb|Sb|b`, 试证明文法 `G[S]` 为二义文法  
   文法 `G[S]` 为 `S->aSb|Sb|b`，对句子 `abbb` 分别进行左推导和右推导，分别得到两颗语法树， 即该语法为二义性语法
   ![](https://pan.lmio.xyz/mio/pic/7d024f078f82ef0045e9d3ac0f7c82c2.jpg)


### 第四章：
----

- 语法制导翻译分为哪几种？  
  主要包括: 属性文法、各种常见中间语言形式、赋值语句的翻译, 布尔表达式的翻译, 控制语句的翻译、说明语句的翻译等
  
- 静态语义检查涉及到哪几个方面？  
  静态语义检查主要涉及类型检查、控制流检查、一致性检查





### 第五章：
----

1. 代码优化的含义是什么？  
   代码优化的含义是:对代码进行等价变换,使得变换后的代码具有更高的时间效率和空间效率





### 第六章：
----

1. 请描述存储空间的静态分配文法。  
   对于那些在编译时刻就可以确定大小的数据对象，在编译时刻就为它们分配存储空间，这样的分配策略称为静态存储分配





### 第七章：
----

1. 所生成的目标代码通常有哪几种形式？  
   目标代码通常采用三种形式:机器语言、汇编语言和待装配机器语言模块




### 第八章：
----

1. 对于编译程序所用的符号表来说，它所涉及的基本操作大致可以归纳为哪几类？  
   在整个编译期间，对于符号表的操作大致可归纳为五类：
   1. 对给定名字，查询此名是否已在表中；
   2. 往表中填入一个新名字；
   3. 对给定名字，访问它的某些信息；
   4. 对给定名字，往表中填写或更新它的某些信息；
   5. 删除一个或一组无用的项。

2. 一个好的编译程序应具有较强的查错或改错能力。请问：什么是查错？  
   查错是编译程序在工作过程中能够准确、及时的将源程序中的各种错误查找出来，并以简明的形式报告错误的性质及出错的位置
   


