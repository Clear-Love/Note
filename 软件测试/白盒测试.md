## 实验目的

## 实验原理
## 实验过程
### 题目一：使用逻辑覆盖测试方法测试以下程序段
```go
func Function(a, b, c int) int {
	if a > 1 && b == 0 {
		c /= a
	}
	if a == 5 || c > 1 {
		c += 1
	}
	return a + b + c
}
```

#### 画出程序控制流图（用题中给出的语句编号表示）

```mermaid {align="center"} 
flowchart TB
start[Start] --a--> cond1{a > 1 && b == 0}
cond1 -- N/b --> cond2{a==5或c>1}
cond1 -- Y/c --> code1[c/=2]
code1 --> cond2
cond2 -- N/d --> ret[返回 a+b+c]
cond2 -- Y/e --> code2[c+=1]
code2 --> ret
ret --> E[End]
```

#### 语句覆盖
	语句覆盖（在语句覆盖测试用例中，使程序中每个可执行语句至少被执行一次。）
- 测试用例

| 测试用例  | 覆盖路径 | 预期结果 |
|----------|---------|----------|
| a=2,b=0,c=4 | a,c,e | 5 |

#### 判定覆盖

	判定覆盖(使得每个判定语句的取值都满足各有一次“真”与“假”)
- 测试用例

| 测试用例 | 覆盖路径 | 预期结果 |
| --- | --- | --- |
| a=2,b=0,c=4 | a, c, e | 5 |
| a=-4, b=3, c=-5 | a, b, d | -6 |
| a=3, b=0, c=-6 | a, c, d | 1 |
| a=5, b=1, c=0| a, b, e | 7 |

#### 条件覆盖
	设计测试用例时，要保证每种状态都至少出现一次。设计测试用例的原则是尽量以最少的测试用例达到最大的覆盖率
- 条件列表

| 条件一 | 条件标记 | 条件二 | 条件标记 |
|--------|---------|--------|---------|
| a>1    | S1      | b=0    | S3      |
| a<=1   | -S1     | b!=0   | -S3     |
| a=5    | S2      | c>1    | S4      |
| a!=5   | -S2     | c<=1   | -S4     |

- 测试用例

| 测试用例 | 条件标记 | 执行路径 | 预期结果 |
| --- | --- | --- | --- |
| a=2,b=0,c=4 | S1, -S2, S3, S4 | a, c, e | 5 |
| a=-4, b=3, c=-5 | -S1,-S2,-S3,-S4 | a, b, d | -6 |
| a=3, b=0, c=-6 | S1,- S2, S3, -S4 | a, c, d | 1 |
| a=5, b=1, c=0| S1, S2, -S3, -S4| a, b, e | 7 |
#### 判断/条件覆盖
	设计用例，使得判断中的每个条件的所有可能结果至少出现一
	次，而且判断本身所有可能结果也至少出现一次
| 测试用例 | 条件标记 | 执行路径 | 预期结果 |
| --- | --- | --- | --- |
| a=2,b=0,c=4 | S1, -S2, S3, S4 | a, c, e | 5 |
| a=-4, b=3, c=-5 | -S1,-S2,-S3,-S4 | a, b, d | -6 |
| a=3, b=0, c=-6 | S1,- S2, S3, -S4 | a, c, d | 1 |
| a=5, b=1, c=0| S1, S2, -S3, -S4| a, b, e | 7 |
#### 条件组合覆盖
	1. 设计足够多的测试用例，使判定语句中每个条件的所有可能至少出现一次，并且每个判定语句本身的判定结果也至少出现一次   
	2. 由于四个条件每个条件都有取“真”、“假”两个值，因此所有条件结果的组合有24=16种
|  序号    |  组合              | 测试用例           | 预期结果 |
|:-------|:-----------------|:---------------|:-----|
|  1     |  S1，S2，S3，S4     | a=5 ,b=0 c=2   |    6 |
|  2     |  -S1，S2，S3，S4    | 不可能            |      |
|  3     |  S1，-S2，S3，S4    |  a=2, b=0, c=2 |    3 |
|  4     |  S1，S2，-S3，S4    | a=5, b=1, c=2  |    9 |
|  5     |  S1，S2，S3，S4     | a=5, b=0, c=1  |    6 |
|  6     |  -S1，-S2，S3, S4  |  a=1, b=0, c=2 |    4 |
|  7     |  -S1，S2，-S3，S4   | 不可能            |      |
|  8     |  -S1，S2，S3，-S4   | 不可能            |      |
|  9     |  S1，-S2，-S3，S4   | a=2, b=1, c=2  |    6 |
|  10    |  S1，S2，-S3，-S4   | a=5,b=1,c=1    |    8 |
|  11    |  S1，-S2，S3，-S4   |  a=2, b=0, c=1 |    2 |
|  12    |  -S1，-S2，-S3，S4  |  a=1, b=1, c=2 |    5 |
|  13    |  -S1，-S2，S3，-S4  |  a=1, b=0, c=1 |    2 |
|  14    |  S1，-S2，-S3，-S4  |  a=3, b=2, c=1 |    6 |
|  15    |  -S1，S2，-S3，-S4  | 不可能            |      |
|  16    |  -S1，-S2，-S3，-S4 |  a=1, b=1, c=1 |    3 |  
#### 测试程序
```go
package whitebox

import (
	"testing"
)

func TestFunction_1(t *testing.T) {
	testCases := []struct {
		a, b, c int
		expectedResult int
	}{
		// 语句覆盖
		{2, 0, 4, 5},
		// 判定覆盖
		{2, 0, 4, 5},
		{-4, 3, -5, -6},
		{3, 0, -6, 1},
		{5, 1, 0, 7},
		// 条件覆盖
		{2, 0, 4, 5},
		{-4, 3, -5, -6},
		{3, 0, -6, 1},
		{5, 1, 0, 7},
		// 判定-条件覆盖
		{2, 0, 4, 5},
		{-4, 3, -5, -6},
		{3, 0, -6, 1},
		{5, 1, 0, 7},
		// 条件组合覆盖
		{5, 0, 2, 6},
		{2, 0, 2, 3},
		{5, 1, 2, 9},
		{5, 0, 1, 6},
		{1, 0, 2, 4},
		{2, 1, 2, 6},
		{5, 1, 1, 8},
		{2, 0, 1, 2},
		{1, 1, 2, 5},
		{1, 0, 1, 2},
		{3, 2, 1, 6},
		{1, 1, 1, 3},
	}

	for _, tc := range testCases {
		if res := Function_1(tc.a , tc.b, tc.c); res != tc.expectedResult {
			t.Errorf("Function_1(%d, %d, %d); 期望输出 %d; 实际输出 %d", tc.a, tc.b, tc.c, tc.expectedResult, res)
		}
	}
}
```
### 题目二：三角形问题

	在三角形计算中，要求输入三角型的三个边长： A、B 和 C。当三边不可能构成三角形时
	提示错误，可构成三角形时计算三角形周长。若是等腰三角形打印“等腰三角形” ，若是
	等边三角形，则提示“等边三角形”。画出程序流程图、控制流程图、计算圈复杂度 V(g) ，
	找出基本测试路径

#### 测试程序

```go
func JudgeTriangle(a, b, c int) string {
	if a <= 0 || b <= 0 || c <= 0 {
		return "非法输入"
	}
	if a+b <= c || a+c <= b || b+c <= a {
		return "无法构成三角形"
	} else if a == b || a == c || b == c {
		if a == b && b == c {
			return "等边三角形"
		} else {
			return "等腰三角形"
		}
	} else if a*a+b*b == c*c || a*a+c*c == b*b || b*b+c*c == a*a {
		return "直角三角形"
	} else {
		return "普通三角形"
	}
}
```

#### 程序流程图


```mermaid
graph TB
    A{"a <= 0 ||
    b <= 0 ||
    c <= 0"} -->|否|B{"a+b <= c ||
    a+c <= b ||
    b+c <= a"}
    A -->|是|C["非法输入"]
    B -->|能构成|D{"a == b || 
    a == c ||
    b == c"}
    B -->|不能构成|E["无法构成三角形"]
    D -->|是|F{"a==b&&b==c"}
    D -->|否|G{"a*a+b*b == c*c ||
    a*a+c*c == b*b ||
    b*b+c*c == a*a"}
    F -->|是|H["等边三角形"]
    F -->|否|I["等腰三角形"]
    G -->|是|J["直角三角形"]
    G -->|否|K["普通三角形"]
    C -->End["结束"]
    E -->End
    H -->End
    I -->End
    J -->End
    K -->End
```
#### 分离程序流图

```mermaid
graph TB
    A1(("a <= 0?"))-->|是|C["非法输入"]
    A2(("b <= 0?"))-->|是|C
    A3(("c <= 0?"))-->|是|C
    A1-->|否|A2
    A2-->|否|A3
    A3-->|否|C1(("a+b <= c?"))
    C1-->|否|C2(("a+c <= b?"))
    C2-->|否|C3(("b+c <= a?"))
    C3-->|否|D1(("a == b?"))
	C1-->|是|E["无法构成三角形"]
	C2-->|是|E
	C3-->|是|E
    D1-->|否|D2(("b == c?"))
    D2-->|否|D3(("a == c?"))
    D3-->|否|I1(("a*a+b*b == c*c?"))
    D1-->|是|F1(("a == b?"))
    D2-->|是|F1
    D3-->|是|F1
    F1-->|是|F2(("b == c?"))
    F2-->|是|G(("等边三角形"))
    F1-->|否|H(("等腰三角形"))
    F2-->|否|H
    I1-->|否|I2((a*a+c*c == b*b?))
    I2-->|否|I3((b*b+c*c == a*a?))
    I3-->|否|K(("普通三角形"))
    I1-->|是|J(("直角三角形"))
    I2-->|是|J
    I3-->|是|J
    C-->End(("结束"))
    E-->End
    G-->End
    H-->End
    K-->End
    J-->End
```

#### 控制流图

```mermaid
graph TB
    A1(("1"))-->|是|C["4"]
    A2(("2?"))-->|是|C
    A3(("3"))-->|是|C
    A1-->|否|A2
    A2-->|否|A3
    A3-->|否|C1(("5"))
    C1-->|否|C2(("6"))
    C2-->|否|C3(("7"))
    C3-->|否|D1(("8"))
	C1-->|是|E["9"]
	C2-->|是|E
	C3-->|是|E
    D1-->|否|D2(("10"))
    D2-->|否|D3(("11"))
    D3-->|否|I1(("12"))
    D1-->|是|F1(("13"))
    D2-->|是|F1
    D3-->|是|F1
    F1-->|是|F2(("14"))
    F2-->|是|G(("15"))
    F1-->|否|H(("16"))
    F2-->|否|H
    I1-->|否|I2(("17"))
    I2-->|否|I3(("18"))
    I3-->|否|K(("19"))
    I1-->|是|J(("20"))
    I2-->|是|J
    I3-->|是|J
    C-->End(("21"))
    E-->End
    G-->End
    H-->End
    K-->End
    J-->End
```
- 根据控制流图，边数E=34, 结点数N=21，判断结点数P=14,`v(g)=E-N+2=15, v(g)=P+1=15`
- 由控制流图可得独立路径有，（包含这一段路径的都算）
	1. 1 -> 4 -> 21 
	2. 2 -> 4 -> 21 
	3. 3 -> 4 -> 21 
	4. 5 -> 9 -> 21 
	5. 6 -> 9 -> 21 
	6. 7 -> 9 -> 21 
	7. 8 -> 13 -> 16 -> 21 （不可能）
	8. 8 -> 13 -> 14 -> 16 -> 21
	9. 8 -> 13 -> 14 -> 15 -> 21
	10. 10 -> 13 -> 16 -> 21 
	11. 11 -> 13 -> 16 -> 21 
	12. 12 -> 20 -> 21 
	13. 17 -> 20 -> 21 
	14. 18 -> 20 -> 21 
	15. 18 -> 19 -> 21 
#### 设计测试用例
| a | b | c | 预期结果    | 覆盖路径 |
|:--|:--|:--|:--------|:-----|
| 0 | 1 | 2 | 非法输入    |    1 |
| 1 | 0 | 2 | 非法输入    |    2 |
| 1 | 2 | 0 | 非法输入    |    3 |
| 1 | 2 | 3 | 无法构成三角形 |    4 |
| 1 | 3 | 2 | 无法构成三角形 |    5 |
| 3 | 1 | 2 | 无法构成三角形 |    6 |
| 5 | 5 | 6 | 等腰三角形   |    8 |
| 5 | 5 | 5 | 等边三角形   |    9 |
| 6 | 5 | 5 | 等腰三角形   |   10 |
| 5 | 6 | 5 | 等腰三角形   |   11 |
| 3 | 4 | 5 | 直角三角形   |   12 |
| 3 | 5 | 4 | 直角三角形   |   13 |
| 5 | 3 | 4 | 直角三角形   |   14 |
| 5 | 6 | 7 | 普通三角形   |   15 |  
#### 测试程序
```go
package whitebox

import "testing"


 func TestJudgeTriangle(t *testing.T) {
	testCases := []struct {
		a, b, c int
		expectedResult string
	}{
		{0, 1, 2, "非法输入"},
		{1, 0, 2, "非法输入"},
		{1, 2, 0, "非法输入"},
		{1, 2, 3, "无法构成三角形"},
		{1, 3, 2, "无法构成三角形"},
		{3, 1, 2, "无法构成三角形"},
		{5, 5, 6, "等腰三角形"},
		{5, 5, 5, "等边三角形"},
		{6, 5, 5, "等腰三角形"},
		{5, 6, 5, "等腰三角形"},
		{3, 4, 5, "直角三角形"},
		{3, 5, 4, "直角三角形"},
		{5, 3, 4, "直角三角形"},
		{5, 6, 7, "普通三角形"},
	}

	for _, tc := range testCases {
		result := JudgeTriangle(tc.a, tc.b, tc.c)
		if result != tc.expectedResult {
			t.Errorf("judgeTriangle(%d, %d, %d), 期望输出： %s, 实际输出：%s",
				tc.a, tc.b, tc.c, tc.expectedResult, result)
		}
	}
}
```
### 题目三：使用基本路径测试方法，为以下程序段设计测试用例。 
```go
package whitebox

func Do(x, a, b int) int {
	if a > 1 && b == 0 {
		x = x / a
	}
	if a == 2 || x > 1 {
		x = x + 1
	}
	return x
}
```
### 程序流程图
```mermaid
graph TD
    start((start))-->input[输入X,A,B]
    input-->condition1{A>1 and B=0}
    condition1--Yes-->operation1[X=X/A]
    condition1--No-->condition2{A=2 or X>1}
    condition2--Yes-->operation2[X=X+1]
    condition2--No-->stop((stop))
    operation1-->condition2
    operation2-->stop
```
#### 分离流程图
```mermaid
graph TB
A((开始)) --> B{A > 1?}
B --Y--> C{B = 0?}
C --Y--> D[X = X / A]
D --> E{A=2?}
B --N--> E
C --N--> E
E --Y-->H[X = X + 1]
E --N--> F{X > 1?}
F --Y--> H
F --N--> I
H --> I((结束))
```
#### 控制流图
```mermaid
graph TB
B((1)) --Y--> C((2))
C --Y--> D((3))
D --> E((4))
B --N--> E
C --N--> E
E --Y--> H((6))
E --N--> F((5))
F --Y-->H
F --N--> I((7))
H --> I
```

	一条独立路径是指，和其他的独立路径相比，至少引入一个新处理语句或一个新判断的程序通路。V(G)值正好等于该程序的独立路径的条数。
- 根据程序流图，边数`E=10` 结点数`N=7`, 判断结点数`P=4`,`v(g)=E-N+2=5, v(g) = P+1 = 5`
- 由图可知独立路径有
	1. `1-4-5-7`
	2. `1-4-5-6-7`
	3. `1-2-4-6-7`
	4. `1-2-4-5-7`
	5. `1-2-3-4-5-7`

#### 设计测试用例
| X | A | B | 预期结果 | 覆盖路径 |
|:--|:--|:--|:-----|:-----|
| 0 | 0 | 0 |    0 |    1 |
| 2 | 0 | 0 |    3 |    2 |
| 0 | 2 | 1 |    1 |    3 |
| 0 | 3 | 1 |    0 |    4 |
| 3 | 3 | 0 |    1 |    5 |  

#### 测试程序
```go
package whitebox

import "testing"

func TestDo(t *testing.T) {
	testCases := []struct {
		x, a, b int
		expectedResult int
	}{
		{0, 0, 0, 0},
		{2, 0, 0, 3},
		{0, 2, 1, 1},
		{0, 3, 1, 0},
		{3, 3, 0, 1},
	}

	for _, tc := range testCases {
		if res := Do(tc.x , tc.a, tc.b); res != tc.expectedResult {
			t.Errorf("Do(%d, %d, %d); 期望输出 %d; 实际输出 %d", tc.x, tc.a, tc.b, tc.expectedResult, res)
		}
	}
}
```
![image.png](https://pan.lmio.xyz/pic/a840cb59a31fcff3590ee2c5319b0433.png)
